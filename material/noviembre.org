* Temas abordados en el transcurso del mes de *noviembre*

** Del temario formal

1. =2025.11.04=

   Para el tema de /algoritmos d√©biles de cifrado/:

   - POODLE (Padding Oracle On Downloaded Legacy Encryption) ‚áí
     [[https://www.cve.org/CVERecord?id=CVE-2014-3566][CVE-2014-3566]]
   - [[https://www.netcraft.com/blog/95-of-https-servers-vulnerable-to-trivial-mitm-attacks][95% of HTTPS servers vulnerable to trivial MITM attacks]] (Netcraft, 2023)
   - [[https://arxiv.org/abs/1809.05681][What's in a Downgrade? A Taxonomy of Downgrade Attacks in the TLS
     Protocol and Application Protocols Using TLS]]

   Y con esto terminamos la unidad 3, ¬´Tipos de ataque¬ª.

2. =2025.11.06= y =2025.11.08=

   Iniciamos con la unidad 4, ¬´Pr√°cticas de programaci√≥n segura¬ª. Si no nos
   cuidamos, podemos caer bastante en repetir lo que vimos en las unidades
   1 y 2, as√≠ que... ¬°busqu√©mosle √°ngulos interesantes! ‚ò∫

   - Patrones de dise√±o seguro: *¬øC√≥mo hacer las cosas bien?*
     - Validaci√≥n centralizada :: Servicio de validaci√≥n √∫nica para evitar
       aplicaciones con validaci√≥n dispersa

       ‚Üí Middleware de validaci√≥n, firewalls de aplicaci√≥n (WAF) ‚Üí [[https://microservices.io/patterns/apigateway.html][API
       Gateway]]

     - Tokens de validaci√≥n por tiempo limitado :: [[https://learn.microsoft.com/en-us/azure/architecture/patterns/valet-key][Patr√≥n /Valet key/]]

     - /Principio/ de Conocimiento M√≠nimo para Datos ("Store/Don't Store")

       - Concepto: Una decisi√≥n de dise√±o consciente y documentada sobre
         qu√© datos se almacenan, con qu√© nivel de detalle y por cu√°nto
         tiempo ‚áí /M√≠nimo Privilegio/ aplicado a los datos.

         Ventaja: Minimiza el impacto de una brecha de datos.

   - Antipatrones: *¬øQu√© cosas hacemos mal si no nos cuidamos?*
     - [[https://cwe.mitre.org/data/definitions/656.html][Seguridad por obscuridad]]

     - [[https://cwe.mitre.org/data/definitions/798.html][Credenciales especificadas /en duro/]] ‚Üí ¬øy qu√© esquemas tenemos para
       evitarlo?

     - [[https://cwe.mitre.org/data/definitions/602.html][Verificaci√≥n del lado de cliente de seguridad del lado del servidor]]

   - El [[https://www.threatmodelingmanifesto.org/][manifiesto del modelado de riesgos]]

3. =2025.11.11=
   - Gesti√≥n de dependencias ::
     1. [[https://www.q2bstudio.com/nuestro-blog/298/gestion-dependencias-software-practicas][Q2B ‚áí Mejores Pr√°cticas para la Gesti√≥n de Dependencias en Proyectos
        de Software]] dice,

	- ¬´ *Uso de Herramientas de Gesti√≥n de Dependencias*: Herramientas
          como Maven, Gradle, o NPM simplifican la gesti√≥n de dependencias
          al automatizar la descarga, actualizaci√≥n, y compatibilidad de
          las mismas. Utilizar estas herramientas no solo ahorra tiempo
          sino que tambi√©n minimiza el riesgo de errores humanos¬ª. ‚Üí
          Discutir al respecto üôÇ

	- ¬´ *Minimizar el Uso de Dependencias*: Aunque pueda parecer
          contraintuitivo, menos es m√°s cuando hablamos de
          dependencias. Eval√∫a cr√≠ticamente si una dependencia es realmente
          necesaria antes de a√±adirla a tu proyecto. Esto no solo
          simplifica la gesti√≥n de dependencias sino que tambi√©n mejora el
          tiempo de carga de tus aplicaciones y p√°ginas web, beneficiando
          el posicionamiento SEO y la experiencia de usuario.¬ª

	- ¬´ *Documentaci√≥n y Seguimiento de Dependencias*: Mantener una
          documentaci√≥n detallada de todas las dependencias, incluidas las
          versiones y su prop√≥sito, es crucial. Esto facilita la
          actualizaci√≥n, el diagn√≥stico de problemas y la colaboraci√≥n
          entre equipos.¬ª

	- ¬´ *Pruebas Rigurosas*: Implementa pruebas automatizadas para
          verificar que las actualizaciones de dependencias no rompan la
          funcionalidad existente. Las pruebas unitarias, de integraci√≥n y
          de sistema son esenciales para garantizar que tu aplicaci√≥n
          funcione como se espera tras cada actualizaci√≥n¬ª. ‚Üí ¬øEs el lugar
          correcto?

     2. [[https://docs.cloud.google.com/software-supply-chain-security/docs/dependencies?hl=es-419][Google Cloud ‚áí Software Supply Chain Security ‚áí Dependency
        Management]]

	- Dependencias /directas/ vs. /indirectas/

	- Herramientas de seguimiento de dependencias

	- Estrategias para el manejo de dependencias

4. =2025.11.13=

   - Manejo de errores ::

     1. [[https://developers.google.com/tech-writing/error-messages/error-handling][General error handling rules]], corto y al punto, explicaci√≥n simple
        del tema

     2. [[https://www.geeksforgeeks.org/dsa/error-handling-in-programming/][Error Handling in Programming]], buen art√≠culo con varias t√©cnicas,
        desde las m√°s b√°sicas, y con ejemplos multi-lenguajes

     3. [[https://hjortberg.substack.com/p/best-practices-for-secure-and-readable-f97][Best Practices for Secure and Readable Code: Error Handling and
        Logging]] detalla aspectos como el /para qu√©/ procesamos los
        errores. Tiene puntos importantes.

     4. [[https://dev.to/ajtech0001/mastering-error-handling-in-rust-a-complete-guide-32aj][Manejo de errores en Rust]] El lenguaje Rust introduce algunas clases
        y comportamientos interesantes (aunque a veces frustrantes) para el
        manejo de errores. Revisemos r√°pidamente.

5. =2025.11.18=

   - Caracter√≠sticas de la evoluci√≥n de los lenguajes de programaci√≥n ::

     La evoluci√≥n de los lenguajes de programaci√≥n y sus caracter√≠sticas de
     seguridad no pueden comprenderse sin entender el momento en que
     aparecieron y el estado de la t√©cnica. Platicamos acerca de la
     necesidad del /c√≥digo auto-modificante/ en las primeras arquitecturas
     y todav√≠a hasta las que hoy en d√≠a se utilizan como microcontroladores
     (familias 6502, Z80). Y revisamos que, hacia principios de los 2000,
     se encontr√≥ que la protecci√≥n /en hardware/ evitando regiones de
     memoria de escritura y ejecutables al mismo tiempo (=W^X= o /W xor X/)
     result√≥ tan importante.

     Hablamos del manejo de memoria en las distintas etapas del desarrollo
     de los lenguajes:

     1. *Sin manejo de memoria, s√≥lo un /tiradero/*: C√≥digo binario
        directo, ensamblador

     2. *Memoria gestionada manualmente*: C (=malloc()= / =free()=),
        Fortran, Pascal(?), C++ (=new()= / =delete()=)

     3. *Recolector de basura*: Java, lenguajes /scripting/ en general,
        .NET

     4. *Gesti√≥n autom√°tica de memoria*: Rust (rasgos principales:
        /inmutabilidad/, /propiedad/, /verificador de pr√©stamos/, /tiempos
        de vida/)

     Tocamos tambi√©n detalles del manejo e inferencia de los /tipos de
     datos/.

6. =2025.11.20=

   - Seguridad en ML / AI ::

     No podemos ignorar la importancia que tendr√°n estas herramientas a
     futuro. ¬øQu√© podemos decir particularmente respecto a su seguridad?

     Un modelo de ML no es solo c√≥digo: es c√≥digo + datos + modelo
     entrenado. La superficie de ataque se ampl√≠a. No s√≥lo se puede atacar
     al c√≥digo, sino que se pueden atacar /comportamientos espec√≠fcos/ a
     partir de los /datos/ (‚Üí Atacar a las inferencias para que /emerjan/
     patrones y predicciones controlados por el atacante /en el mundo
     real/)

     1. *Ataque de envenenamiento de datos*: El atacante tiene acceso
        (parcial o total) a los datos de entrenamiento. Introduce ejemplos
        etiquetados incorrectamente o con sesgos maliciosos ‚Üí El modelo
        "aprende" este patr√≥n err√≥neo y lo replica. (Ejemplo ‚Üí Microsoft
        Tey, 2016). Envenenamiento de datos de /re-entrenamiento/.

	Mitigaci√≥n ‚Üí /Validaci√≥n y procedencia de datos/; /Detecci√≥n de
        outliers/; /Aprendizaje robusto/.

     2. *Ataques evasivos o adversariales*: Un atacante manipula datos /con
        el modelo ya en producci√≥n/ buscando que el modelo lo califique
        incorrectamente ‚Üí Perturbaciones peque√±as, tal vez imperceptibles
        al humano, en la entrada, maximizando el /error del modelo/. Una
        vez encontrado el modelo de error, se puede replicar con alta
        probabilidad de √©xito.

	Mitigaci√≥n ‚Üí /Entrenamiento adversarial/ (incluir datos con
        perturbaciones adversariales como parte del entrenamiento);
        /Detecci√≥n de datos adversariales/ (segundo modelo corriendo en
        paralelo, especializado en encontrar patrones adversariales sobre
        la entrada), /Robustificaci√≥n del modelo/ (modelos m√°s
        grandes/robustos o con t√©cnicas espec√≠ficas para entorpecer o
        ignorar a las perturbaciones mas habituales).

     3. *Extracci√≥n del modelo*: Un atacante busca /clonar el modelo/,
        enviando cientos de miles o millones de solicitudes al API y
        entrenando a un modelo local. Ejemplo habitual: Clasificador de
        im√°genes.

	Mitigaci√≥n ‚Üí /Rate limiting/, monitoreo, ofuscaci√≥n de salidas (no
        otorgar todas las etiquetas, s√≥lo las m√°s destacadas), entregar
        patrones /marca de agua/.

   - Checklist de Seguridad para un Proyecto de ML ::

     - Datos :: ¬øValidamos la procedencia y calidad de los datos de entrenamiento?

     - Modelo :: ¬øHemos evaluado la robustez del modelo frente a ataques
       adversariales?

     - Entrenamiento :: ¬øEl pipeline de entrenamiento es seguro?
       (credenciales, acceso)

     - Despliegue :: ¬øLa API del modelo est√° segura? (autenticaci√≥n, rate
       limiting)

     - Monitoreo :: ¬øMonitorizamos las predicciones para detectar "data
       drift" o ataques?
